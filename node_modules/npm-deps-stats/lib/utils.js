'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.locateRoot = locateRoot;
exports.readDeps = readDeps;
exports.readNpmMeta = readNpmMeta;
exports.formatGitHubUrl = formatGitHubUrl;
exports.getGithubUrl = getGithubUrl;
exports.getGithubMatrix = getGithubMatrix;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _child_process = require('child_process');

var _cheerio = require('cheerio');

var _cheerio2 = _interopRequireDefault(_cheerio);

var _request = require('request');

var _request2 = _interopRequireDefault(_request);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function locateRoot(basedir) {
  try {
    if (!basedir) {
      basedir = process.cwd();
    }
    var pkgPath = basedir + '/package.json';
    _fs2.default.statSync(pkgPath);
    return pkgPath;
  } catch (e) {
    if (basedir === '/') {
      throw new Error('not a Node project');
    }

    var base = _path2.default.dirname(basedir);
    return locateRoot(base);
  }
}

function readDeps(pkgJSON) {
  return new Promise(function (resolve, reject) {
    _fs2.default.readFile(pkgJSON, function (err, data) {
      if (err) {
        reject(err);
      } else {
        var deps = [];
        var meta = JSON.parse(data.toString());
        var rawDeps = Object.assign({}, meta.devDependencies, meta.dependencies);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.entries(rawDeps)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 1);

            var name = _step$value[0];

            deps.push(name);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        resolve(deps);
      }
    });
  });
}

function readNpmMeta(name) {
  return new Promise(function (resolve, reject) {
    var p = (0, _child_process.spawn)('npm', ['view', '--json', name]);

    var error = '';
    var out = '';
    p.stdout.on('data', function (data) {
      out += data.toString();
    });

    p.stderr.on('data', function (data) {
      error += data.toString();
    });

    p.on('exit', function () {
      if (error) {
        reject(error);
      } else {
        resolve(out);
      }
    });
  });
}

function formatGitHubUrl(githubUrl) {
  if (githubUrl.match('github.com')) {
    var cuts = githubUrl.split(':');
    if (cuts[0] === 'git@github.com') {
      cuts[0] = 'https://github.com';
    } else if (cuts[0] === 'git+https') {
      cuts[0] = 'https:/';
    } else if (cuts[0] === 'git') {
      cuts[0] = 'https:/';
    } else {
      cuts[0] += ':/';
    }

    return cuts.join('/').replace('////', '//');
  }

  throw new Error('not a github url');
}

function getGithubUrl(npmMeta) {
  var meta = JSON.parse(npmMeta);
  var url = meta.repository && meta.repository.url || meta.homepage;
  if (url) {
    return formatGitHubUrl(url);
  }

  throw new Error('cannot found url or homepage of ' + meta.name);
}

function getGithubMatrix(url) {
  return new Promise(function (resolve, reject) {
    (0, _request2.default)(url, function (error, response, body) {
      if (error) {
        reject(error);
      } else {
        try {
          var $ = _cheerio2.default.load(body);
          var starNode = $('div').find('a.social-count');
          var watchings = starNode[0].attribs['aria-label'].split(' ')[0];
          var stars = starNode[1].attribs['aria-label'].split(' ')[0];
          var forks = starNode[2].attribs['aria-label'].split(' ')[0];

          var issues = $('nav').find('span.counter');
          var openingIssues = issues && issues[0] && issues[0].children && issues[0].children[0] && issues[0].children[0].data || 0;

          resolve({
            watchings: parseInt(watchings, 10),
            stars: parseInt(stars, 10),
            forks: parseInt(forks, 10),
            issues: parseInt(openingIssues, 10)
          });
        } catch (e) {
          reject(e);
        }
      }
    });
  });
}